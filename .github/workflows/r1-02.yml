name: R1-02 – Repos & Use-cases (Drift)

on:
  workflow_dispatch: {}
  # можно запустить вручную из вкладки Actions

permissions:
  contents: write
  pull-requests: write

jobs:
  r1_02:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Flutter version
        run: flutter --version

      - name: Configure git user
        run: |
          git config user.name "listyb-bot"
          git config user.email "actions@users.noreply.github.com"

      - name: Create feature branch
        run: |
          git switch -c feature/r1-02-repos-usecases
          
      - name: Apply hotfix (DAO imports, forTesting, DAO helpers)
        shell: bash
        run: |
          set -euo pipefail

          APP_DB="lib/data/db/app_database.dart"
          LISTS_DAO="lib/data/db/daos/lists_dao.dart"
          ITEMS_DAO="lib/data/db/daos/items_dao.dart"

          # 1) app_database.dart — добавить импорты DAO ПЕРЕД 'part', затем добавить forTesting
          if ! grep -q "daos/lists_dao.dart" "$APP_DB"; then
            # Вставляем 2 импорта прямо перед первой строкой part 'app_database.g.dart';
            perl -0777 -pe "s|part 'app_database.g.dart';|import 'daos/lists_dao.dart';\nimport 'daos/items_dao.dart';\n\npart 'app_database.g.dart';|;" -i "$APP_DB"
          fi

          # Добавляем именованный конструктор forTesting, если его нет
          if ! grep -q "AppDatabase.forTesting" "$APP_DB"; then
            perl -0777 -pe "s|(class AppDatabase extends _\\\$AppDatabase\\s*\\{\\s*AppDatabase\\(QueryExecutor e\\) : super\\(e\\);)|\\1\n  AppDatabase.forTesting\\(QueryExecutor e\\) : super\\(e\\);|s" -i "$APP_DB"
          fi

          # 2) lists_dao.dart — удобный метод createList(String)
          if ! grep -q "Future<int> createList" "$LISTS_DAO"; then
            perl -0777 -pe "s|(Future<int> insertList\\(ListsTableCompanion data\\) => into\\(listsTable\\)\\.insert\\(data\\);)|\\1\n\n  /// Convenience for tests\n  Future<int> createList\\(String title\\) {\\n    final now = DateTime.now\\(\\);\\n    return insertList\\(ListsTableCompanion.insert\\(\\n      title: title.trim\\(\\),\\n      archived: const Value\\(false\\),\\n      sortOrder: const Value\\(0\\),\\n      createdAt: now,\\n      updatedAt: now,\\n    \\)\\);\\n  }|s" -i "$LISTS_DAO"
          fi

          # 3) items_dao.dart — удобный метод createItem(...) с ИМЕНОВАННЫМИ параметрами
          if ! grep -q "Future<int> createItem" "$ITEMS_DAO"; then
            perl -0777 -pe "s|(Future<int> insertItem\\(ItemsTableCompanion data\\) => into\\(itemsTable\\)\\.insert\\(data\\);)|\\1\n\n  /// Convenience for tests\n  Future<int> createItem\\({required int listId, required String title, int position = 0}\\) {\\n    final now = DateTime.now\\(\\);\\n    return insertItem\\(ItemsTableCompanion.insert\\(\\n      listId: listId,\\n      title: title.trim\\(\\),\\n      isDone: const Value\\(false\\),\\n      position: Value\\(position\\),\\n      createdAt: now,\\n      updatedAt: now,\\n      completedAt: const Value\\(null\\),\\n    \\)\\);\\n  }|s" -i "$ITEMS_DAO"
          fi

          git add "$APP_DB" "$LISTS_DAO" "$ITEMS_DAO" || true
          git commit -m "fix(r1-02): import DAOs in AppDatabase, add forTesting ctor, add DAO test helpers" || echo "Nothing to commit"
      - name: Apply hotfix (DAOs imports, forTesting ctor, createList())
        shell: bash
        run: |
          set -euo pipefail
      
          # 1) app_database.dart — импорт DAO + конструктор forTesting
          APP_DB="lib/data/db/app_database.dart"
      
          # Вставляем импорты DAO сразу после 'part' строки, если их нет
          if ! grep -q "daos/lists_dao.dart" "$APP_DB"; then
            awk '
              /part '"'"'app_database.g.dart'"'"';/ && !p {
                print $0;
                print "";
                print "// Drift DAOs imports (hotfix for generator visibility)";
                print "import '\''daos/lists_dao.dart'\'';";
                print "import '\''daos/items_dao.dart'\'';";
                p=1; next
              }
              { print $0 }
            ' "$APP_DB" > "$APP_DB.tmp" && mv "$APP_DB.tmp" "$APP_DB"
          fi
      
          # Добавляем именованный конструктор forTesting, если его нет
          if ! grep -q "AppDatabase.forTesting" "$APP_DB"; then
            awk '
              /class AppDatabase extends _\$AppDatabase/ { inClass=1 }
              inClass && /AppDatabase\(QueryExecutor e\) : super\(e\);/ && !added {
                print "  AppDatabase.forTesting(QueryExecutor e) : super(e);"
                added=1
              }
              { print }
            ' "$APP_DB" > "$APP_DB.tmp" && mv "$APP_DB.tmp" "$APP_DB"
          fi
      
          # 2) lists_dao.dart — добавить createList(title)
          LISTS_DAO="lib/data/db/daos/lists_dao.dart"
          if ! grep -q "Future<int> createList" "$LISTS_DAO"; then
            # Вставляем метод после insertList(...)
            awk '
              {print}
              /Future<int> insertList\(ListsTableCompanion data\) => into\(listsTable\)\.insert\(data\);/ && !added {
                print "";
                print "  /// Convenience helper for tests: create a list with current timestamps.";
                print "  Future<int> createList(String title) {";
                print "    final now = DateTime.now();";
                print "    return insertList(ListsTableCompanion.insert(";
                print "      title: title.trim(),";
                print "      archived: const Value(false),";
                print "      sortOrder: const Value(0),";
                print "      createdAt: now,";
                print "      updatedAt: now,";
                print "    ));";
                print "  }";
                print "";
                added=1
              }
            ' "$LISTS_DAO" > "$LISTS_DAO.tmp" && mv "$LISTS_DAO.tmp" "$LISTS_DAO"
          fi
      
          # 3) (опционально) items_dao.dart — быстрый хелпер createItem(...)
          # Если понадобится — раскомментируйте блок ниже:
          #
          # ITEMS_DAO="lib/data/db/daos/items_dao.dart"
          # if ! grep -q "Future<int> createItem" "$ITEMS_DAO"; then
          #   awk '
          #     {print}
          #     /Future<int> insertItem\(ItemsTableCompanion data\) => into\(itemsTable\)\.insert\(data\);/ && !added {
          #       print "";
          #       print "  /// Convenience helper for tests: create an item with current timestamps.";
          #       print "  Future<int> createItem(int listId, String title, {int position = 0}) {";
          #       print "    final now = DateTime.now();";
          #       print "    return insertItem(ItemsTableCompanion.insert(";
          #       print "      listId: listId,";
          #       print "      title: title.trim(),";
          #       print "      isDone: const Value(false),";
          #       print "      position: Value(position),";
          #       print "      createdAt: now,";
          #       print "      updatedAt: now,";
          #       print "      completedAt: const Value(null),";
          #       print "    ));";
          #       print "  }";
          #       print "";
          #       added=1
          #     }
          #   ' "$ITEMS_DAO" > "$ITEMS_DAO.tmp" && mv "$ITEMS_DAO.tmp" "$ITEMS_DAO"
          # fi
      
          # Зафиксируем изменения отдельным коммитом
          git add lib/data/db/app_database.dart lib/data/db/daos/lists_dao.dart || true
          git commit -m "fix: import DAOs in AppDatabase, add forTesting ctor, add ListsDao.createList()" || echo "Nothing to commit"
          
      # ⬇️ СКРИПТ ДОБАВЛЕНИЯ ФАЙЛОВ (скелет домена/даты/тестов)
      # Мы кладём готовые файлы из «встроенного» здесь блока. Для компактности
      # добавляем их через bash heredoc. При желании можно разбить на множественные шаги.
      - name: Add sources (domain/data/tests)
        shell: bash
        run: |
          mkdir -p lib/core/clock
          mkdir -p lib/domain/entities lib/domain/repositories lib/domain/validation
          mkdir -p lib/domain/usecases/lists lib/domain/usecases/items
          mkdir -p lib/data/db/daos lib/data/mappers lib/data/repositories
          mkdir -p test/data test/domain/validation test/domain/usecases
          
          # core
          cat > lib/core/clock/clock.dart <<'EOF'
          abstract class Clock { DateTime now(); }
          class SystemClock implements Clock { const SystemClock(); @override DateTime now() => DateTime.now(); }
          EOF

          # domain entities
          cat > lib/domain/entities/yb_list.dart <<'EOF'
          import 'package:meta/meta.dart';
          @immutable
          class YbList {
            final int id; final String title; final bool archived;
            final DateTime createdAt; final DateTime updatedAt; final int sortOrder;
            const YbList({required this.id,required this.title,required this.archived,required this.createdAt,required this.updatedAt,required this.sortOrder});
            YbList copyWith({String? title,bool? archived,DateTime? updatedAt,int? sortOrder}) =>
              YbList(id:id,title:title??this.title,archived:archived??this.archived,createdAt:createdAt,updatedAt:updatedAt??this.updatedAt,sortOrder:sortOrder??this.sortOrder);
          }
          EOF

          cat > lib/domain/entities/yb_item.dart <<'EOF'
          import 'package:meta/meta.dart';
          @immutable
          class YbItem {
            final int id; final int listId; final String title; final bool isDone;
            final int position; final DateTime createdAt; final DateTime updatedAt; final DateTime? completedAt;
            const YbItem({required this.id,required this.listId,required this.title,required this.isDone,required this.position,required this.createdAt,required this.updatedAt,this.completedAt});
            YbItem copyWith({String? title,bool? isDone,int? position,DateTime? updatedAt,Object? completedAt=_noChange}) =>
              YbItem(id:id,listId:listId,title:title??this.title,isDone:isDone??this.isDone,position:position??this.position,createdAt:createdAt,updatedAt:updatedAt??this.updatedAt,completedAt:identical(completedAt,_noChange)?this.completedAt:completedAt as DateTime?);
          }
          const _noChange = Object();
          EOF

          cat > lib/domain/entities/yb_counts.dart <<'EOF'
          class YbCounts { final int total; final int active; final int done;
            const YbCounts({required this.total, required this.active, required this.done}); }
          EOF
          # validation
          cat > lib/domain/validation/validation_errors.dart <<'EOF'
          class ValidationError implements Exception {
            final String message; const ValidationError._(this.message);
            const ValidationError.emptyTitle({required String entity}) : this._('Empty $entity title is not allowed');
            ValidationError.tooLong({required String entity, required int max}) : this._('$entity title exceeds $max chars');
            @override String toString() => message;
          }
          EOF

          cat > lib/domain/validation/validators.dart <<'EOF'
          import 'validation_errors.dart';
          const int kMaxListTitle=120; const int kMaxItemTitle=200;
          void validateListTitle(String title){ final t=title.trim(); if(t.isEmpty) throw const ValidationError.emptyTitle(entity:'list'); if(t.length>kMaxListTitle) throw ValidationError.tooLong(entity:'list',max:kMaxListTitle); }
          void validateItemTitle(String title){ final t=title.trim(); if(t.isEmpty) throw const ValidationError.emptyTitle(entity:'item'); if(t.length>kMaxItemTitle) throw ValidationError.tooLong(entity:'item',max:kMaxItemTitle); }
          EOF

          # repositories (domain)
          cat > lib/domain/repositories/lists_repository.dart <<'EOF'
          import '../entities/yb_list.dart'; import '../entities/yb_counts.dart';
          abstract class ListsRepository{
            Future<int> create(String title);
            Future<void> rename(int listId,String newTitle);
            Future<void> archive(int listId,{required bool archived});
            Future<void> delete(int listId);
            Stream<List<YbList>> watchAll({bool includeArchived=false});
            Stream<YbList?> watchOne(int listId);
            Stream<Map<int,YbCounts>> watchCountsForAll({bool includeArchived=false});
            Stream<YbCounts> watchCounts(int listId);
          }
          EOF

          cat > lib/domain/repositories/items_repository.dart <<'EOF'
          import '../entities/yb_item.dart';
          abstract class ItemsRepository{
            Future<int> add(int listId,String title,{int? position});
            Future<void> update(YbItem item);
            Future<void> toggle(int itemId);
            Future<void> reorder(int listId,List<int> orderedItemIds);
            Future<void> delete(int itemId);
            Stream<List<YbItem>> watchForList(int listId,{bool? onlyDone,bool? onlyActive});
            Stream<YbItem?> watchOne(int itemId);
          }
          EOF

          # use-cases (lists)
          cat > lib/domain/usecases/lists/create_list_uc.dart <<'EOF'
          import '../../repositories/lists_repository.dart'; import '../../validation/validators.dart';
          class CreateListUc{ final ListsRepository repo; CreateListUc(this.repo);
            Future<int> call(String title){ validateListTitle(title); return repo.create(title); } }
          EOF

          cat > lib/domain/usecases/lists/rename_list_uc.dart <<'EOF'
          import '../../repositories/lists_repository.dart'; import '../../validation/validators.dart';
          class RenameListUc{ final ListsRepository repo; RenameListUc(this.repo);
            Future<void> call(int id,String newTitle){ validateListTitle(newTitle); return repo.rename(id,newTitle); } }
          EOF

          cat > lib/domain/usecases/lists/archive_list_uc.dart <<'EOF'
          import '../../repositories/lists_repository.dart';
          class ArchiveListUc{ final ListsRepository repo; ArchiveListUc(this.repo);
            Future<void> call(int id,{required bool archived})=>repo.archive(id,archived:archived); }
          EOF

          cat > lib/domain/usecases/lists/delete_list_uc.dart <<'EOF'
          import '../../repositories/lists_repository.dart';
          class DeleteListUc{ final ListsRepository repo; DeleteListUc(this.repo); Future<void> call(int id)=>repo.delete(id); }
          EOF

          cat > lib/domain/usecases/lists/watch_lists_uc.dart <<'EOF'
          import '../../entities/yb_list.dart'; import '../../repositories/lists_repository.dart';
          class WatchListsUc{ final ListsRepository repo; WatchListsUc(this.repo);
            Stream<List<YbList>> call({bool includeArchived=false})=>repo.watchAll(includeArchived:includeArchived); }
          EOF

          cat > lib/domain/usecases/lists/watch_list_uc.dart <<'EOF'
          import '../../entities/yb_list.dart'; import '../../repositories/lists_repository.dart';
          class WatchListUc{ final ListsRepository repo; WatchListUc(this.repo); Stream<YbList?> call(int id)=>repo.watchOne(id); }
          EOF

          cat > lib/domain/usecases/lists/watch_counts_uc.dart <<'EOF'
          import '../../entities/yb_counts.dart'; import '../../repositories/lists_repository.dart';
          class WatchCountsUc{ final ListsRepository repo; WatchCountsUc(this.repo); Stream<YbCounts> call(int listId)=>repo.watchCounts(listId); }
          EOF

          cat > lib/domain/usecases/lists/watch_all_counts_uc.dart <<'EOF'
          import '../../entities/yb_counts.dart'; import '../../repositories/lists_repository.dart';
          class WatchAllCountsUc{ final ListsRepository repo; WatchAllCountsUc(this.repo);
            Stream<Map<int,YbCounts>> call({bool includeArchived=false})=>repo.watchCountsForAll(includeArchived:includeArchived); }
          EOF

          # use-cases (items)
          cat > lib/domain/usecases/items/add_item_uc.dart <<'EOF'
          import '../../repositories/items_repository.dart'; import '../../validation/validators.dart';
          class AddItemUc{ final ItemsRepository repo; AddItemUc(this.repo);
            Future<int> call(int listId,String title,{int? position}){ validateItemTitle(title); return repo.add(listId,title,position:position); } }
          EOF

          cat > lib/domain/usecases/items/update_item_uc.dart <<'EOF'
          import '../../repositories/items_repository.dart'; import '../../validation/validators.dart'; import '../../entities/yb_item.dart';
          class UpdateItemUc{ final ItemsRepository repo; UpdateItemUc(this.repo);
            Future<void> call(YbItem item){ validateItemTitle(item.title); return repo.update(item); } }
          EOF

          cat > lib/domain/usecases/items/toggle_item_uc.dart <<'EOF'
          import '../../repositories/items_repository.dart';
          class ToggleItemUc{ final ItemsRepository repo; ToggleItemUc(this.repo); Future<void> call(int itemId)=>repo.toggle(itemId); }
          EOF

          cat > lib/domain/usecases/items/reorder_items_uc.dart <<'EOF'
          import '../../repositories/items_repository.dart';
          class ReorderItemsUc{ final ItemsRepository repo; ReorderItemsUc(this.repo); Future<void> call(int listId,List<int> orderedIds)=>repo.reorder(listId,orderedIds); }
          EOF

          cat > lib/domain/usecases/items/delete_item_uc.dart <<'EOF'
          import '../../repositories/items_repository.dart';
          class DeleteItemUc{ final ItemsRepository repo; DeleteItemUc(this.repo); Future<void> call(int id)=>repo.delete(id); }
          EOF

          cat > lib/domain/usecases/items/watch_items_uc.dart <<'EOF'
          import '../../entities/yb_item.dart'; import '../../repositories/items_repository.dart';
          class WatchItemsUc{ final ItemsRepository repo; WatchItemsUc(this.repo);
            Stream<List<YbItem>> call(int listId,{bool? onlyDone,bool? onlyActive})=>repo.watchForList(listId,onlyDone:onlyDone,onlyActive:onlyActive); }
          EOF

          cat > lib/domain/usecases/items/watch_item_uc.dart <<'EOF'
          import '../../entities/yb_item.dart'; import '../../repositories/items_repository.dart';
          class WatchItemUc{ final ItemsRepository repo; WatchItemUc(this.repo); Stream<YbItem?> call(int id)=>repo.watchOne(id); }
          EOF
          # data: drift DB/DAO
          cat > lib/data/db/app_database.dart <<'EOF'
          import 'package:drift/drift.dart';
          import 'package:drift/native.dart';
          part 'app_database.g.dart';
          class ListsTable extends Table{
            IntColumn get id=>integer().autoIncrement()();
            TextColumn get title=>text()();
            BoolColumn get archived=>boolean().withDefault(const Constant(false))();
            IntColumn get sortOrder=>integer().withDefault(const Constant(0))();
            DateTimeColumn get createdAt=>dateTime()();
            DateTimeColumn get updatedAt=>dateTime()();
          }
          class ItemsTable extends Table{
            IntColumn get id=>integer().autoIncrement()();
            IntColumn get listId=>integer().references(ListsTable,#id,onDelete: KeyAction.cascade)();
            TextColumn get title=>text()();
            BoolColumn get isDone=>boolean().withDefault(const Constant(false))();
            IntColumn get position=>integer().withDefault(const Constant(0))();
            DateTimeColumn get createdAt=>dateTime()();
            DateTimeColumn get updatedAt=>dateTime()();
            DateTimeColumn get completedAt=>dateTime().nullable()();
          }
          @DriftDatabase(tables:[ListsTable,ItemsTable], daos:[ListsDao,ItemsDao])
          class AppDatabase extends _$AppDatabase{ AppDatabase(QueryExecutor e):super(e); @override int get schemaVersion=>1; }
          AppDatabase makeInMemoryDb()=>AppDatabase(NativeDatabase.memory());
          EOF

          cat > lib/data/db/daos/lists_dao.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../app_database.dart';
          part 'lists_dao.g.dart';
          @DriftAccessor(tables:[ListsTable,ItemsTable])
          class ListsDao extends DatabaseAccessor<AppDatabase> with _$ListsDaoMixin{
            ListsDao(AppDatabase db):super(db);
            Future<int> insertList(ListsTableCompanion data)=> into(listsTable).insert(data);
            Future<void> updateList(int id,ListsTableCompanion data)=> (update(listsTable)..where((t)=>t.id.equals(id))).write(data);
            Future<void> deleteList(int id)=> (delete(listsTable)..where((t)=>t.id.equals(id))).go();
            Stream<List<ListsTableData>> watchAll({bool includeArchived=false}){
              final q = select(listsTable)..orderBy([(t)=>OrderingTerm.asc(t.sortOrder),(t)=>OrderingTerm.asc(t.id)]);
              if(!includeArchived) q.where((t)=>t.archived.equals(false));
              return q.watch();
            }
            Stream<ListsTableData?> watchOne(int id)=> (select(listsTable)..where((t)=>t.id.equals(id))).watchSingleOrNull();
            Stream<Map<int,({int total,int active,int done})>> watchCountsForAll({bool includeArchived=false}){
              final sql = '''
              SELECT l.id AS listId, COUNT(i.id) AS total,
                     SUM(CASE WHEN i.is_done=0 THEN 1 ELSE 0 END) AS active,
                     SUM(CASE WHEN i.is_done=1 THEN 1 ELSE 0 END) AS done
              FROM lists_table l
              LEFT JOIN items_table i ON i.list_id=l.id
              ${includeArchived ? '' : 'WHERE l.archived=0'}
              GROUP BY l.id
              ''';
              return customSelect(sql,readsFrom:{listsTable,itemsTable}).watch().map((rows){
                final m=<int,({int total,int active,int done})>{};
                for(final r in rows){
                  m[r.read<int>('listId')]=(total:r.read<int>('total'),active:r.read<int?>('active')??0,done:r.read<int?>('done')??0);
                }
                return m;
              });
            }
            Stream<({int total,int active,int done})> watchCounts(int listId){
              final sql='''
              SELECT COUNT(i.id) AS total,
                     SUM(CASE WHEN i.is_done=0 THEN 1 ELSE 0 END) AS active,
                     SUM(CASE WHEN i.is_done=1 THEN 1 ELSE 0 END) AS done
              FROM items_table i WHERE i.list_id=?
              ''';
              return customSelect(sql,variables:[Variable.withInt(listId)],readsFrom:{itemsTable}).watchSingle()
              .map((r)=>(total:r.read<int>('total'),active:r.read<int?>('active')??0,done:r.read<int?>('done')??0));
            }
          }
          EOF

          cat > lib/data/db/daos/items_dao.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../app_database.dart';
          part 'items_dao.g.dart';
          @DriftAccessor(tables:[ItemsTable])
          class ItemsDao extends DatabaseAccessor<AppDatabase> with _$ItemsDaoMixin{
            ItemsDao(AppDatabase db):super(db);
            Future<int> insertItem(ItemsTableCompanion data)=> into(itemsTable).insert(data);
            Future<void> updateItem(int id,ItemsTableCompanion data)=> (update(itemsTable)..where((t)=>t.id.equals(id))).write(data);
            Future<void> deleteItem(int id)=> (delete(itemsTable)..where((t)=>t.id.equals(id))).go();
            Stream<List<ItemsTableData>> watchByList(int listId,{bool? onlyDone,bool? onlyActive}){
              final q=(select(itemsTable)..where((t)=>t.listId.equals(listId))
                ..orderBy([(t)=>OrderingTerm.asc(t.position),(t)=>OrderingTerm.asc(t.id)]));
              if(onlyDone==true) q.where((t)=>t.isDone.equals(true));
              if(onlyActive==true) q.where((t)=>t.isDone.equals(false));
              return q.watch();
            }
            Stream<ItemsTableData?> watchOne(int id)=> (select(itemsTable)..where((t)=>t.id.equals(id))).watchSingleOrNull();
            Future<void> reorderItems(int listId,List<int> orderedIds) async{
              await transaction(() async{
                for(var i=0;i<orderedIds.length;i++){
                  await (update(itemsTable)..where((t)=>t.id.equals(orderedIds[i]) & t.listId.equals(listId)))
                    .write(ItemsTableCompanion(position:Value(i)));
                }
              });
            }
          }
          EOF
          # mappers
          cat > lib/data/mappers/list_mappers.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../../domain/entities/yb_list.dart';
          import '../db/app_database.dart';
          extension ListsRowToEntity on ListsTableData{
            YbList toEntity()=>YbList(id:id,title:title,archived:archived,sortOrder:sortOrder,createdAt:createdAt,updatedAt:updatedAt);
          }
          extension YbListToCompanion on YbList{
            ListsTableCompanion toCompanion()=>ListsTableCompanion(
              id:Value(id),title:Value(title),archived:Value(archived),sortOrder:Value(sortOrder),createdAt:Value(createdAt),updatedAt:Value(updatedAt));
          }
          EOF

          cat > lib/data/mappers/item_mappers.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../../domain/entities/yb_item.dart';
          import '../db/app_database.dart';
          extension ItemsRowToEntity on ItemsTableData{
            YbItem toEntity()=>YbItem(id:id,listId:listId,title:title,isDone:isDone,position:position,createdAt:createdAt,updatedAt:updatedAt,completedAt:completedAt);
          }
          extension YbItemToCompanion on YbItem{
            ItemsTableCompanion toCompanion()=>ItemsTableCompanion(
              id:Value(id),listId:Value(listId),title:Value(title),isDone:Value(isDone),position:Value(position),createdAt:Value(createdAt),updatedAt:Value(updatedAt),completedAt:Value(completedAt));
          }
          EOF

          cat > lib/data/mappers/counts_mappers.dart <<'EOF'
          import '../../domain/entities/yb_counts.dart';
          extension TupleToCounts on ({int total,int active,int done}){ YbCounts toCounts()=>YbCounts(total:total,active:active,done:done); }
          EOF

          # repositories impl
          cat > lib/data/repositories/lists_repository_impl.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../../core/clock/clock.dart';
          import '../../domain/entities/yb_list.dart';
          import '../../domain/entities/yb_counts.dart';
          import '../../domain/repositories/lists_repository.dart';
          import '../db/app_database.dart';
          import '../db/daos/lists_dao.dart';
          import '../mappers/list_mappers.dart';
          import '../mappers/counts_mappers.dart';
          class ListsRepositoryImpl implements ListsRepository{
            final ListsDao _dao; final Clock _clock;
            ListsRepositoryImpl(this._dao,this._clock);
            @override Future<int> create(String title){
              final now=_clock.now();
              return _dao.insertList(ListsTableCompanion.insert(title:title.trim(),archived:const Value(false),sortOrder:const Value(0),createdAt:now,updatedAt:now));
            }
            @override Future<void> rename(int listId,String newTitle){
              final now=_clock.now();
              return _dao.updateList(listId,ListsTableCompanion(title:Value(newTitle.trim()),updatedAt:Value(now)));
            }
            @override Future<void> archive(int listId,{required bool archived}){
              final now=_clock.now();
              return _dao.updateList(listId,ListsTableCompanion(archived:Value(archived),updatedAt:Value(now)));
            }
            @override Future<void> delete(int listId)=>_dao.deleteList(listId);
            @override Stream<List<YbList>> watchAll({bool includeArchived=false})=>_dao.watchAll(includeArchived:includeArchived).map((rows)=>rows.map((r)=>r.toEntity()).toList());
            @override Stream<YbList?> watchOne(int listId)=>_dao.watchOne(listId).map((r)=>r?.toEntity());
            @override Stream<Map<int,YbCounts>> watchCountsForAll({bool includeArchived=false})=>_dao.watchCountsForAll(includeArchived:includeArchived).map((m)=>m.map((k,v)=>MapEntry(k,v.toCounts())));
            @override Stream<YbCounts> watchCounts(int listId)=>_dao.watchCounts(listId).map((v)=>v.toCounts());
          }
          EOF

          cat > lib/data/repositories/items_repository_impl.dart <<'EOF'
          import 'package:drift/drift.dart';
          import '../../core/clock/clock.dart';
          import '../../domain/entities/yb_item.dart';
          import '../../domain/repositories/items_repository.dart';
          import '../db/app_database.dart';
          import '../db/daos/items_dao.dart';
          import '../mappers/item_mappers.dart';
          class ItemsRepositoryImpl implements ItemsRepository{
            final ItemsDao _dao; final AppDatabase _db; final Clock _clock;
            ItemsRepositoryImpl(this._dao,this._db,this._clock);
            @override Future<int> add(int listId,String title,{int? position}) async{
              final now=_clock.now(); final pos=position ?? await _nextPosition(listId);
              return _dao.insertItem(ItemsTableCompanion.insert(listId:listId,title:title.trim(),isDone:const Value(false),position:Value(pos),createdAt:now,updatedAt:now,completedAt:const Value(null)));
            }
            Future<int> _nextPosition(int listId) async{
              final q=await (_db.select(_db.itemsTable)..where((t)=>t.listId.equals(listId))..orderBy([(t)=>OrderingTerm.desc(t.position)])..limit(1)).get();
              return q.isEmpty?0:q.first.position+1;
            }
            @override Future<void> update(YbItem item)=>_dao.updateItem(item.id,item.toCompanion());
            @override Future<void> toggle(int itemId) async{
              final now=_clock.now();
              await _db.transaction(() async{
                final row=await (_db.select(_db.itemsTable)..where((t)=>t.id.equals(itemId))).getSingle();
                final newDone=!row.isDone;
                await _dao.updateItem(itemId,ItemsTableCompanion(isDone:Value(newDone),updatedAt:Value(now),completedAt:Value(newDone?now:null)));
              });
            }
            @override Future<void> reorder(int listId,List<int> orderedItemIds)=>_dao.reorderItems(listId,orderedItemIds);
            @override Future<void> delete(int itemId)=>_dao.deleteItem(itemId);
            @override Stream<List<YbItem>> watchForList(int listId,{bool? onlyDone,bool? onlyActive})=>_dao.watchByList(listId,onlyDone:onlyDone,onlyActive:onlyActive).map((rows)=>rows.map((r)=>r.toEntity()).toList());
            @override Stream<YbItem?> watchOne(int itemId)=>_dao.watchOne(itemId).map((r)=>r?.toEntity());
          }
          EOF
          # tests
          cat > test/data/db_in_memory.dart <<'EOF'
          import 'package:drift/native.dart';
          import 'package:listyb/data/db/app_database.dart';
          AppDatabase makeInMemoryDb()=>AppDatabase(NativeDatabase.memory());
          EOF

          cat > test/domain/validation/validators_test.dart <<'EOF'
          import 'package:flutter_test/flutter_test.dart';
          import 'package:listyb/domain/validation/validators.dart';
          import 'package:listyb/domain/validation/validation_errors.dart';
          void main(){
            test('list title cannot be empty',(){ expect(()=>validateListTitle('   '), throwsA(isA<ValidationError>())); });
            test('item title max length',(){ final long='a'*(kMaxItemTitle+1); expect(()=>validateItemTitle(long), throwsA(isA<ValidationError>())); });
            test('trim accepted',(){ expect(()=>validateListTitle('  Milk  '), returnsNormally); });
          }
          EOF
          cat > test/domain/usecases/lists_usecases_test.dart <<'EOF'
          import 'package:flutter_test/flutter_test.dart';
          import 'package:listyb/core/clock/clock.dart';
          import 'package:listyb/data/db/app_database.dart';
          import 'package:listyb/data/db/daos/lists_dao.dart';
          import 'package:listyb/data/repositories/lists_repository_impl.dart';
          import 'package:listyb/domain/usecases/lists/archive_list_uc.dart';
          import 'package:listyb/domain/usecases/lists/create_list_uc.dart';
          import 'package:listyb/domain/usecases/lists/rename_list_uc.dart';
          class FixedClock implements Clock{ final DateTime _now; FixedClock(this._now); @override DateTime now()=>_now; }
          void main() async{
            test('create/rename/archive list and watch streams',() async{
              final db=makeInMemoryDb();
              final repo=ListsRepositoryImpl(ListsDao(db), FixedClock(DateTime.utc(2025,1,1)));
              final create=CreateListUc(repo); final rename=RenameListUc(repo); final archive=ArchiveListUc(repo);
              final id=await create('Groceries'); expect(id, greaterThan(0));
              final lists=await repo.watchAll().first; expect(lists.single.title,'Groceries');
              await rename(id,'Food'); final updated=await repo.watchOne(id).first; expect(updated?.title,'Food');
              await archive(id, archived:true); final visible=await repo.watchAll().first; expect(visible.isEmpty,true);
              final countsMap=await repo.watchCountsForAll().first; expect(countsMap.containsKey(id), false);
            });
          }
          EOF

          cat > test/domain/usecases/items_usecases_test.dart <<'EOF'
          import 'package:flutter_test/flutter_test.dart';
          import 'package:listyb/core/clock/clock.dart';
          import 'package:listyb/data/db/app_database.dart';
          import 'package:listyb/data/db/daos/items_dao.dart';
          import 'package:listyb/data/db/daos/lists_dao.dart';
          import 'package:listyb/data/repositories/items_repository_impl.dart';
          import 'package:listyb/data/repositories/lists_repository_impl.dart';
          import 'package:listyb/domain/usecases/items/add_item_uc.dart';
          import 'package:listyb/domain/usecases/items/reorder_items_uc.dart';
          import 'package:listyb/domain/usecases/lists/create_list_uc.dart';
          class FixedClock implements Clock{ final DateTime _now; FixedClock(this._now); @override DateTime now()=>_now; }
          void main() async{
            test('add, toggle, reorder items and counts reflect',() async{
              final db=makeInMemoryDb(); final clock=FixedClock(DateTime.utc(2025,1,1));
              final listsRepo=ListsRepositoryImpl(ListsDao(db), clock);
              final itemsRepo=ItemsRepositoryImpl(ItemsDao(db), db, clock);
              final createList=CreateListUc(listsRepo);
              final addItem=AddItemUc(itemsRepo); final reorder=ReorderItemsUc(itemsRepo);
              final listId=await createList('Groceries');
              final milk=await addItem(listId,'Milk'); final bread=await addItem(listId,'Bread'); final rice=await addItem(listId,'Rice');
              await itemsRepo.toggle(milk); final milkRow=await itemsRepo.watchOne(milk).first;
              expect(milkRow?.isDone,true); expect(milkRow?.completedAt,isNotNull);
              await reorder(listId,[rice,milk,bread]); final items=await itemsRepo.watchForList(listId).first;
              expect(items.map((e)=>e.title).toList(), ['Rice','Milk','Bread']);
              final counts=await listsRepo.watchCounts(listId).first; expect(counts.done,1); expect(counts.active,2); expect(counts.total,3);
            });
          }
          EOF

      - name: Ensure pubspec has dependencies
        run: |
          # добавим зависимости если их нет (идемпотентно)
          if ! grep -q "drift:" pubspec.yaml; then
            awk '1;/^dependencies:/{print "  drift: ^2.18.0\n  sqlite3_flutter_libs: ^0.5.24\n  meta: ^1.12.0"}' pubspec.yaml > pubspec.tmp && mv pubspec.tmp pubspec.yaml
          fi
          if ! grep -q "drift_dev:" pubspec.yaml; then
            awk '1;/^dev_dependencies:/{print "  drift_dev: ^2.18.0\n  build_runner: ^2.4.12\n  test: ^1.25.0\n  mocktail: ^1.0.3"}' pubspec.yaml > pubspec.tmp && mv pubspec.tmp pubspec.yaml
          fi

      - name: Flutter pub get
        run: flutter pub get

      - name: Generate Drift
        run: dart run build_runner build --delete-conflicting-outputs

      - name: Run tests
        run: flutter test -r expanded

      - name: Commit and push branch
        run: |
          git add .
          git commit -m "R1-02: Domain entities, Drift DAO & repositories, mappers, use-cases, unit tests" || echo "No changes to commit"
          git push -u origin feature/r1-02-repos-usecases

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: feature/r1-02-repos-usecases
          base: main
          title: "R1‑02: Domain entities, Drift repositories/DAO, mappers, use‑cases, tests"
          body: |
            **R1‑02 – Репозитории и Use‑cases (локально, Drift)**

            **Что сделано**
            - Domain entities: `YbList`, `YbItem`, `YbCounts`.
            - Абстрактные репозитории: `ListsRepository`, `ItemsRepository`.
            - Drift‑схема: `ListsTable`, `ItemsTable` (cascade delete).
            - DAO: `ListsDao`, `ItemsDao` + кастомные агрегаты `counts()`.
            - Мапперы DB↔Entity.
            - Use‑cases:
              - Lists: create / rename / archive / delete / watchAll / watchOne / watchCounts / watchAllCounts
              - Items: add / update / toggle / reorder / delete / watchForList / watchOne
            - Unit‑тесты: валидаторы, happy‑path, edge‑кейсы (in‑memory Drift).

            **Как проверить**
            ```
            flutter pub get
            dart run build_runner build --delete-conflicting-outputs
            flutter test
            ```

            **Примечания**
            - ID: int autoincrement; reorder: `position:int` с транзакцией.
            - Архивация: soft‑флаг; по умолчанию исключается в watch/counts.
